<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="favicon.svg" />
  </head>

<body>
<script src="remark-latest.min.js"></script>
<textarea id="source">

class: center, middle
2023/18/02, 11:00

# Portage Python sur Webassembly

## Pour quoi, pour qui et comment ?

---

# Sommaire


1. Anatomie des Applications python typiques, et leur besoins.
2. Les clients typiques et leur besoins.
3. Le Cauchemar du portage.
4. Simplifier l'accès aux applications via WebAssembly.
5. Mise en pratique ( hors slide )
6. conclusion.
---

# Pour quoi ? Pour des applications.

## Anatomie des Applications python typiques

    - vt100 / vt420 :  fontes à chasse fixe, unicode et sixel


    - Applications 2D : framebuffer:plein écran, fenêtrée: X11/Wayland/natif.
        accélération matérielle : GL/GLES/Vulkan/Metal SIMD/NEON OpenCL/CUDA
        interface : EGL/GLX/DirectX/Metal

    - Applications 3D/VR.
        accélération matérielle : GL/GLES/Vulkan/Metal SIMD/NEON OpenCL/CUDA
        interface : EGL/GLX/DirectX/Metal

    - Applications accédant aux capteurs matériels
        audio/gyro/accel/touch/usb/série/gestion energie.
        accès aux bus : usb / i2c / spi etc

    - Applications désirant fournir des couches d'accessibilité fiables.


---
# Pour qui ? des utilisateurs variés sur des machines qui le sont encore plus.

    - Windows : pas de vt100/420 ni de serveur X, pas toujours unicode.
    - systeme de types unix :  pas de vt420, pas toujours unicode.
    - mac : pas toujours de serveurs X

    - couches 3D hétéroclites : opengl / gles / vulkan / directX / metal.

    - système kiosques : tres hétérogènes et souvent tres restreint.

    - ultraportables/webos : difficultés pour lancer python.

---

    - dans tous les cas des versions hétéroclites de Python et un support tierce partie souvent incomplet ( ou lag => mac).
    - peut etre une impossiblité d'installer ou d'éxécuter une application avec les simples droits d'utilisateur
    - et souvent des couches d'accessibilité négligées ou non standardisées.

---

# Le Cauchemar du portage:
    - problème du portage natif : la méthode difficile est trop difficile ...
    - Solutions ?
---

## Le Cauchemar du portage:
### problème du portage natif : la méthode difficile est trop difficile ...

    - trouver et redistribuer des terminaux vt420 pour toutes les plateformes.
            mintty / mlterm / mac?

    - utiliser uniquement des dénominateurs communs ?
        à toutes les platformes graphiques :
            SDL2
        et pour tous les capteurs plyer https://github.com/kivy/plyer#supported-apis )
            NB: le meilleur support de plyer est pour une plateforme non supportée par Python !

    - maintenir des binaires pour toutes les combinaisons hardware+software/os
        win32/win64/winarm, android x4, GNU/Linux 32/64 x4, ios, macos

    - treize à la douzaine à multiplier par le nombre de version de Python ...

    le problème ne date pas d'hier ! https://en.wikipedia.org/wiki/UNCOL#cite_note-2

---
# Le Cauchemar du portage: Solutions ?

    S'écarter des solutions natives semblerait être la solution :
    mais il faut un bon compromis encombrement/performance/sécurité.
    on ne peut avoir les 3 en même temps donc quel argument de vente choisir ?


    Si l'idée ne date pas d'hier pourquoi on a pas de solutions existantes ?
    en fait il y en a, mais elle ont dévoyé et ont toutes imposé un language ...
    et/ou des api natives pour les taches courantes : api dures, voire impossible à porter.

--
    Pourtant au fil du temps, il y a eu de nombreuses VM comme :

    perl : 1987 - bon début - mais problème pour passer à la version 6 vers la fin.

    python : 1991 pas encombrant (à l'époque) , pas de sécurité pour maximiser les performances
            -> OS dépendant pour plein d'éléments ( X11/Tk, api win32, différences de libc ... )

    ruby : assez similaire.


    java : 1995 implémentations concurrentes, souvent performance au détriment de la  sécurité avec jni
        malgré de nombreux frontends jython/jruby/quercus(php)
        la mayonnaise ne prend pas et probablement problème de license(s)

    llvm-ir 2000: n'est pas utilisable par les humains, seulement les compilateurs
    N'a meme pas une machine virtuelle soignée/portable.

    parrotvm : pas de compilateurs.

--
    et même des tentatives "universelles" (en apparence) sur le web :
--
        la + connue :
            plugin_flash.gif
--
        la + ouverte :
            plugin_java.jpg
--

    qui pour l'utilisateur se résument souvent à :
            plugin_none.png

--


    nodejs 2009 : pas mal, le seul probleme de taille c'est qu'il ne comprend que le javascript ...

    asm.js 2013 : on prend le dénominateur commun de tout le monde : le C
    Et on le fait cibler une vm universelle bien moins complexe que llvm : vm qui tourne même dans nodejs (ouf enfin autre chose que du javascript)
    ceci constitue un modèle viable et en preuve de concept au lieu de Doom il fait tourner un clone de quake3* en réseau.

    * BananaBread Cube 2: Sauerbraten engine

    CloudABI (Ed Schouten) ** qui résume les points communs des OS à une cinquante d'appel système
    donne indirectement naissance à

    WebAssembly 2015 :  C/C++/rust compilent sans problème pour une machine virtuelle.
    Machine qui elle même est tres facile à compiler partout ou un compilateur C a vu le jour. ( genre 5 minutes sur la  WII pourtant ppc/big-endian )

    La machine virtuelle sera partout grace à W3C en 2019 !

    Pourquoi wasm a gagné ? A cause de l'argument de vente choisi: il est idéal et c'est la sécurité !
    WebAssembly n'a pas de registres, et pas de goto. problème réglé c'est un vrai bac à sable.
    Cerise sur le gateau les performances ne sont pas mauvaises : et à l'ère de la fibre optique et des gigaoctets de ram dans les mobiles
    l'encombrement ne semble plus un si grand problème.
    L'autre point fort :  c'est juste un standard (MVP 1.0) que tout monde peut implémenter ou il veut, comme il veut. Pas de problème de license.
    Et il n'est pas si compliqué ( tout l'opposé de llvm-ir ou jvm ) : le coût de maintenance devient très faible et il y a une sérieuse batterie de tests.

    Et surtout les gafam en ont besoin sur le web.
---
    Mais même les PME/TPE en ont besoin:
---

FRA:

- La demande : e-learning avec de la 3D, tourne sur un LMS ("learning management system"), doit s'intégrer dans du HTML5

- les contraintes : dans un environnement corporate ou institutionnel, on ne peut jamais rien installer sur les machines

- pourquoi la 3D ?
        - pour former des technicien-nes, des mecanicien-nes
        - pour montrer des dispositifs mécaniques et leurs fonctionnement (animé, interactif)
        - amméliorer l'interactivité et qualité des interfaces des métiers pour attirer les jeunes talents qui sont habitués aux consoles 3D à la maison.

- Et les interfaces pouvant aussi bien gérer un avatar que le vrai matériel, voire meme partager du code ...


https://youtu.be/AOGFXxhKGWw?t=89

--> SI ON PEUT interface DearImGUI + Bras Robot qui réagit à l'interface en vrai.

---





---
-------- FACULTIF  --------------


Pendant ce temps du coté portabilité Python il y a eu ...
comme personne ne voulait sacrifier les performances ...
---

##    La méthode "force brute" : docker
    sécurité pas forcément au point ...

---
##    Les méthodes classiques ( à tendance lourde).
        PyQt : super, mais problème de license.
        Kivy : super, mais installation d'un python complet et d'une pile de librairies pour chaque app.
        Electron+flask : installation d'un browser complet pour chaque app, afin de résoudre les problemes de GUI.
    sécurité - vraiment - discutable même si code source fourni ( eg supply chain attack ).

-------- FACULTIF  --------------

---


# Simplifier l'accès aux applications via WebAssembly.

    Et si on pouvait utiliser un python complet ( comme fait kivy ) ? Mais commun
    à toutes les app

    utiliser la VM d'un navigateur deja installé et entretenu par le vendeur ?

---

## Le navigateur internet : vers une machine virtuelle universelle ?


Le navigateur EST une machine virtuelle :

    asm.js : poc, lent. Mais plus besoin de coder en javascript !

    aujourd'hui remplacé par WebAssembly : à peine 2x moins rapide que natif.


Le navigateur a un accès universel à presque tout les capteurs !

    ramener à nouveau le tableau de plyer, ajouter colonne support navigateur/javascript.



---

TODO une slide minimum par XP: Mise en pratique / livecoding.


---

## pygbag:  test serveur local + hello world avec input

        async.png


## pygbag: fibonnaci: montrer que ça ne fonctionne plus

        async-noblock.png

        solution : sched_yield.

        expliquer que la vm python pourrait corriger le probleme au lieu de forcer
        a écrire du async/await partout (rant!)


SOUS RESERVE DE LA TECHNO WASI:
    pygbag+xtermjs-sixel ( comme évolution/remplacement de la POC python-wasm de Ethan Smith )



    pygbag+SDL2 : pygame ( comme évolution/remplacement de replit/kata.games )
    un ou 2 jeux vite fait.



## packaging image , son ,

 mais on peut aussi packager des modeles 3d  et shaders :


FRA:  demo possible du bras robot virtuel




BONUS:


    pygbag+WebGL : Harfang3D une solution alternative au toolkits 3D en javascript et bien + portable.


    pygbag sur mobile via debugger chromium ?
    -> cable usb avec une tablette ou téléphone ( un qui pédale par contre le wasm est LENT à compil )

    webusb : démontrer la possibilité d'un atelier technique en présentiel ?
     ->  websocket / telemetrix / retour par cam

    faire démo opencv / AR en live ?

    balancer un QR sur VPI pour expérience participative via mobile
    ( eg prog P2P ou système de vote pour questions réponses)



Revenir à la  slide finale pour les questions
---

# Conclusion

## Super ça marche ! Mais ( car il y a toujours un mais ...)

    Ne PAS faire la course à la nouveauté ( 64bits/threads/servicesworkers/webgpu/simd-neon)
    => coller à MVP.

    Ne PAS pousser le hardware.
    => GLES 1/2 devrait suffire aux besoins.

    Mettez au maximum votre app dans un module, et utilisez des imports relatifs.

    Ne pas perdre son temps à obfusquer le code, annotez le pour le compiler + tard avec mypyc.

    Programmer de façon éco-responsable sur du vieux matériel.

    Privilégier l'accessibilité. Surtout sur mobile.


Car le but est d'amener toutes les applications, à tout le monde, partout.


---
TODO:

timing des chapitres

caler la liste de plyer pour format slide/VPI.

au moins 2 laptop ( ben non j'en ai pas et celui de ma fille est pas adapté du tout )

un point d'acces wifi captif pour experience en live( j'ai, mais limite max de client inconnue)

trouver un env de livecoding self hosted qui passe sur un VPI

avoir une camera filaire+pied sur table pour renvoyer gros plan sur VPI dans le cas d'une démo sur mobile ou devboard

des T-shirts harfang XXL si ça existe ...


REF:
CLOUDABI :
    https://youtu.be/3N29vrPoDv8

    ** CloudABI is based on the Capsicum lightweight OS capability and sandbox framework developed at the University of Cambridge Computer Laboratory.


Is WebAssembly the return of Java Applets & Flash? :
    https://steveklabnik.com/writing/is-webassembly-the-return-of-java-applets-flash


</textarea>
</body>
<script defer>var slideshow = remark.create();</script>
</html>
